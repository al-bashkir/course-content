## Поговорим про ООП
Объектно-ориентированное программирование — это подход, который используется в многих современных языках программирования. Он позволяет приблизить код к реальной жизни.

В реальной жизни нас окружают не переменные или функции, а обычные **объекты**. Когда мы используем ООП, мы программируем объекты, описываем их свойства и возможности.
  
Возьмем к примеру обычную кошку. У нее есть параметры: цвет шерсти, цвет глаз, кличка. Также она может выполнять различные действия: мурлыкать, шипеть и царапаться.

## Классы
Только что мы схематически описали всех кошек в целом. Подобное описание свойств и действий какого-либо объекта на языке Python называется **классом**. Класс – это описание атрибутов и функций, присущих всем объектам этого класса. В нашем случае названием класса будет «кошка».
          
Для создания класса надо написать ключевое слово ``class`` и затем указать его имя: ``class Cat:``.Помните, что кошка может выполнять действия?. Мы описываем эти действия при помощи функций внутри класса. Их принято называть **методами** класса. Определим эти методы при помощи Python:
```python
class Cat: 
    def meow(self): 
        print("Meow!") 

    def hiss(self):
        print("Кшшш!") 

    def scrabble(self): 
        print("Царап-царап!")
```
Это обычные функции из прошлой недели, только пишем мы их внутри класса и доступны они только из класса. Внимательно следите за табами — один *таб* на один уровень вложенности. Метод будет на расстоянии одного таба, а его содержание двух.

А что еще за ``self``? Давайте разбираться. Для этого добавим внутрь класса нашей кошки еще один метод:

```python
def do_everything(self): 
    self.meow() 
    self.hiss() 
    self.scrabble()    
```

Параметр ``self`` позволяет классу обращаться к самому себе. Там хранится ссылка на сам экземпляр класса. Без этого аргумента выполнить подобные действия мы бы не смогли. Его всегда нужно указывать первым параметром при объявлении метода. Но не нужно передавать при вызове!

Мы уже говорили, что у класса есть также есть *атрибуты*. Для удобства в любом классе можно определить функцию-конструктор `__init__()`. 

Эта функция автоматически вызывается в момент создания объекта. Про объекты нашего класса мы поговорим дальше. Так может выглядеть наш метод-конструктор:

```python
class Cat: 
    def __init__(self, wool_color, eyes_color, name):
        self.wool_color = wool_color 
        self.eyes_color = eyes_color 
        self.name = name
```

Почему это *«конструктор»*? Потому что он получает обычные аргументы и «привязывает» их классу через `self`. Код конструктора выше позволяет нам после этого создать объект класса: `my_cat = Cat("grey", "green", "Monya")`.  
  
Если бы у нас не было метода-конструктора, нам бы пришлось сначала создать объект класса: `my_cat = Cat()`, и только затем добавлять свойства `my_cat.name = 'Monya'` по одному — это было бы неудобно.

## Объекты
А чем в нашем коде будет переменная `my_cat`? Она будет хранить объект класса **Cat**, который мы создали. Давайте проверим и вызовем свойства, которые мы передали при создании:

```python      
# код выведет построчно: grey, green, Monya     
print(my_cat.wool_color)
print(my_cat.eyes_color) 
print(my_cat.name)
```

Атрибуты кошки можно изменять. Например, давайте сменим кличку нашей кошки: `my_cat.name = "Meowooka"`. Имя изменится и вы увидите это запринтив его. Также из нашего объекта мы можем вызывать все методы.`my_cat.meow()`

### Наследование
Кстати, классы могут **наследоваться** друг от друга. Тогда свойства и методы передаются от родительского класса к дочернему. 

```python
class Animal():
    ## содержит все общие свойства для животных

class Cat(Animal):
    ## содержит все общие свойства для животных и специфичные для кошек
```
Наследование довольно часто используется при разработке сложных систем. Наследование может достигать десятков уровней вложенности, от базовых классов к узконаправленным.

Поэтому не удивляйтесь, когда при изучении Джанго начнете часто встречать такие конструкции.

• • •

Отлично, вот мы и разобрались с работой класса на примере кошки. Но на самом деле программисты не пишут кошек и других животных. Как и другие примеры реального мира.

ООП в Python используется для программирования абстракций. Клиентов для запроса кода или обработчиков событий.

Например для нашего бота можно было бы сделать класс `TelegramClient` или `BotHandler`

У него бы были методы для получения апдейтов, отправки сообщений, обработки команд. И свойства содержащие ссылку на API и токен.

## Серверы
На прошлом этапе мы говорили про историю интернета и про общение «сервер-клиент». Мы в нашем коде выступали клиентом, который сначала взаимодействовал с АПИ телеграма, затем с АПИ биржы.

Настало время поговорить про серверы и написать свой. На самом деле код сервера ничем особо не будет отличаться от нашего когда бота. Но сначала немного теории: поговорим о том, что происходит, когда вы переходите по ссылке из браузера.

### Адрес хоста
У всех сайтов в интернете есть как **доменное имя** — bluzir.me, так и **IP-адрес** — 82.202.236.100. Узнать IP-адрес сервера можно через терминал, если ввести `ping bluzir.me`. Вы можете ввести в браузере IP-адрес и увидеть, что результат одинаковый.

Но все-таки отличия есть: IP-адрес ведет напрямую на сервер и привязан к нему. Буквенный домен ни к чему не привязан, он выполняет роль **маски** для IP-адреса, потому что такой домен проще запомнить.

Когда вы вводите доменный адрес сайта в строку браузера, то браузер на самом деле связывает доменный и IP-адрес. После чего перенаправляет вас по IP-адресу, но адресную строку оставляет прежней, чтобы вас не пугать.

Но как браузер понимает какие домены связаны с какими IP-адресами?

### DNS-серверы

Они помогают браузеру в определении IP-адреса по доменному имени. Возможно вы сталкивались с ними, если настраивали роутер или получали ошибку о том, что страница не грузится.

Их много: он свой у каждого провайдера, большие компании рекомендуют людям ставить свой, у Гугла — `8.8.8.8`. Но для работы интернета достаточно одного работающего DNS-сервера.

После того, как получил от нас имя домена, браузер делает запрос на DNS-сервер. А тот уже возвращает IP-адрес нужного сервера и происходит переход. Сайтов в интернете очень много и чтобы DNS-сервер работал быстро используются много техник оптимизации.

Проще всего представить его в виде огромного питоновского словаря, где ключи — домены, а значения — IP-адреса.

### Порты
Еще один важный момент. На самом деле полный адрес сервера состоит не только из IP. У него есть еще порт и целиком адрес выглядит вот так — `82.202.236.100:80`.

У сервера может быть множество функций: раздача сайта пользователям, отправка писем, выдача данных из базы и тд. Для всего этого тоже делаются запросы по IP-адресу сервера. Порт нужен, чтобы сразу понять назначение запроса.

Нам нужно запомнить несколько портов: **80** — стандартный HTTP-порт, раздает сайт по обычному соединению; **443** — стандартный HTTPS-порт, раздает сайт по защищенному соединению; **8000** — будем использовать для локальной разработки сервера.

## Пишем сервер
Помните, что весь код уже написан за нас? Веб-сервер нам тоже не придется писать с нуля. Даже более того, в Python встроен простой и максимально легкий веб-сервер.

Просто введите команду из нашей директории **shop_demo**: `python3 -m http.server 8000`. Теперь вводите в браузер `127.0.0.1:8000` — магия. Хотя и не очень похоже на сервер, он просто раздает все файлы из директории **shop_demo**. Даже нашу папку **.git**, которая обычно скрыта. **127.0.0.1** (0.0.0.0) — это наш localhost, IP-адрес нашего компьютера для самого себя. Мы поднимаем свой сервер на этом адресе и порте 8000.

Открывайте директории и посмотрите в терминал. Там есть вся инфорация о запросе: IP-адрес клиента — тоже localhost, ведь вы все делаем локально; время запроса; тип запроса — GET (**получаем** файлы с сервера); код ответа — дает понять насколько успешно завершился запрос.

[Список кодов ответов для ознакомления](https://httpstatuses.com)

Помните урок про историю интернета и **HTML**? Такой наш сервер с легкостью справится с раздачей HTML и CSS файлов. Таким образом можно было бы раздавать сайт вроде этого курса. Мы только переходим по ссылкам на уроки. Никакая логика не затрагивается.

На самом же деле большинство сайтов сейчас динамические и такой сервер не справится. Тут на на помощь приходят **фреймворки**. Фреймворк — это набор компонентов, которые помогают разрабатывать веб-сайты быстро и просто.В нашем случае мы будем использовать веб-фреймворк **Django**. Про него мы подробнее мы поговорим в следующем уроке.

• • •

# Почаще задавайте вопросы в чате — там обязательно помогут
