## Вступление
В прошлом примере мы запринтили html и он был похож на кашу текста. Мы могли бы его отоформатировать, но с ним все равно было бы неудобно работать.

По этой причине у большинства современных сайтов есть специальный интерфейс для разработчиков. Программный интерфейс приложения – **API**. Он использует тот же HTTP с GET и POST запросами. Но вместо HTML там приходит намного более удобный для парсинга формат — **JSON**.

Он вышел из языка Javascript и расшифровывается, как _JavaScript Object Notation_. Он представляет из себя сериализованный объект языка JavaScript, но также подходит для передачи почти любого вида информации. Так может выглядеть JSON-ответ для интернет-магазина:
```json
[
  {
    "id": 1,
    "title": "Adidas Originals NMD_RACER PRIMEKNIT ",
    "description": "Прогрессивные, премиальные, инновационные. Кроссовки NMD сочетают в себе наследие adidas и современные материалы",
    "price": 8990
  },
  {
    "id": 2,
    "title": "Adidas Originals EQT CUSHION ADV",
    "description": "В 90-е линейка EQT произвела настоящую революцию в мире беговой обуви",
    "price": 6690
  },
  {
    "id": 3,
    "title": "Adidas Originals STAN SMITH PRIMEKNIT",
    "description": "Вплетая современные инновации в классический дизайн, эти кроссовки Stan Smith объединяют силуэт оригинальной теннисной модели 1972 года",
    "price": 5690
  }
]
```


## API Телеграма
Пользовались ботами в телеграме? Они тоже работают именно так. Но как нам написать своего бота? Давайте разбираться. Так выглядит запрос к бот-АПИ телеграма:

`https://api.telegram.org/bot[токен-бота]/[метод-апи]`

_Важно:_ Если вы из России, то АПИ Телеграма скорее всего не откроется. Для обхода блокировки мы будем использовать один из бесплатных VPN-сервисов: [TunnelBear](https://www.tunnelbear.com/), [Windscribe](https://rus.windscribe.com/) или расширение для браузера [friGate](https://fri-gate.org/ru/).
Проверить, что они работают можно через основной сайт [Телеграм.орг](https://telegram.org).

Что еще за токены и методы АПИ? **Токен** передается для идентификации бота, получить его можно у [официального бота телеграма](http://t-do.ru/botfather). Вам потребуется создать своего бота и выпустить для него токен. 

Метод же требуется, чтобы сказать АПИ, что именно мы хотим сделать с этим ботом — получить сообщения или ответить на них.
Для получения информации о боте вызывается метод **getMe**. 

В итоге URL выглядит будет выглядеть так:

`https://api.telegram.org/bot163576261:AAEeEiqFLwLfAiUhXdMQE906RA-bwE4vKCg/getMe`

На него нужно будет сделать **GET**-запрос. Как мы уже знаем, для этого мы можем просто перейти по ссылке в браузере или сделать запрос из кода.

Замените в этой ссылке токен на свой. В результате получим:
```json        
{
  "ok": true, 
  "result": 
    { 
      "id": 163576861, 
      "is_bot": true, 
      "first_name": "R2D2", 
      "username": "bluzirbot" 
    } 
}    
```      
Если вы попытались перейти по ссылке с моим токеном, то получите ошибку, потому что он не настоящий. Токен это приватная информация и никто не должен его узнать, кроме вас.

### Делаем запросы из кода 
Теперь давайте сделаем такой же запрос, но уже при помощи кода и библиотеки *requests*:
```python
import requests

url = "https://api.telegram.org/bot163576261:AAEeEiqFLwLfAiUhXdMQE906RA-bwE4vKCg/getMe"
response = requests.get(url)
  
# форматируем json в словарь
decoded = response.json()
print(decoded)	
```

Не забыли вставить свой токен? Ответ должен быть такой же, как и из браузера. Но что мы только что сделали?

- Положили наш URL в переменную **url**
- Передали переменную **url** в функцию *get* библиотеки *requests*
- Получили ответ от сервера и переформатировали его при помощи функции **json()** в питон-словарь
- Сохранили это в переменную и вывели это

После преобразования мы можем запросить нужные данные по ключу словаря. Еще не забыли, как они работают? Сначала обращаемся к ключу `'result'`. Затем к вложенному ключу `'id'`.

```python

bot_result = decoded['result']`
bot_id = bot_result['id']

# также можем сделать это сразу
bot_id = decode['result']['id']
```
В результате получим переменную с ID нашего бота и с можем её вывести. *Принт* — это также отличное средство для отладки. Когда не понимаете какой-то кусок кода, просто разбейте его на переменные и выведите их.

### Работа с документацией
Давайте напишем функцию, которая будет получать новые сообщения через метод **getUpdates** . Этот метод подробно описан в [документации](https://core.telegram.org/bots/api#getupdates). 

Большинство документации для разработчиков написано на английском языке — стоит просто принять это. Документация бот-АПИ не исключение. Есть [неофициальный перевод](https://tlgrm.ru/docs/bots/api#getting-updates), но он не полный. Также неофициальная документация может просто перестать обновляться и это приведет к ошибкам.
  
Взглянем на левый столбик таблицы с описанием метода. Там показаны **параметры**, которые принимает метод. Затем их **типы** — почти такие же, как типы данных из урока про основы Python. Затем указывается **обязательный** ли это параметр для передачи — если обязательный, то запрос без него выдаст ошибку. И в последнем столбце написано подробное **описание** поля. 

Что такое параметры? Вспомните начало урока, где я показывал пример с поиском Гитхаба через *квери-параметры*. АПИ тоже принимает такие параметры, чтобы уточнить действие.

### Получаем апдейты

Наша функция для получения апдейтов будет выглядеть так:
```python
def get_bot_updates():
    url = "https://api.telegram.org/bot163576261:AAEeEiqFLwLfAiUhXdMQE906RA-bwE4vKCg/getUpdates"
    result = requests.get(url)
	
    # форматируем json в словарь
    decoded = result.json()
    return decoded['result']

get_bot_updates()
```  

Получаем ответ от API и снова форматируем в словарь:
```python         
[
  {
    'update_id': 17584178, 
    'message': 
      {
        'message_id': 734, 
        'from': 
          {
            'id': 723014, 
            'is_bot': False, 
            'first_name': 'Vladislav',
            'last_name': 'Kooklev', 
            'username': 'bluzir', 
            'language_code': 'ru-RU'
          }, 
        'chat': 
          {
            'id': 723014, 
            'first_name': 'Vladislav',
            'last_name': 'Kooklev', 
            'username': 'bluzir', 
            'type': 'private'
          }, 
        'date': 1518505077, 
        'text': 'Сообщения для курса по Python'
      }, 
  }
]
```
            
          
В документации вы могли увидеть, что **getUpdates** принимает параметры *limit* и *offset*. Первый отвечает за количество сообщений, которые мы получим за один запрос. Второй понадобится, чтобы отмечать сообщения прочитанными.

Чтобы передать параметры, их потребуется записать в виде словаря. Затем передать в аргумент **params** функции **get**, также как мы передавали *url*.

```python
def get_bot_updates(limit):
    url = "https://api.telegram.org/<token>/getUpdates" 
	
    # записываем параметры в словарь
    par = {'limit': limit} 
	
    # передаем словарь в аргумент функции
    result = requests.get(url, params=par)
	
    # форматируем json в словарь
    decoded = result.json()
    return decoded['result']
  
# Получим только пять апдейтов
result = get_bot_updates(5)
```          
        
Теперь мы будем получать только 5 сообщений за раз.

Я уже говорил, что словари могут содержать внутри и строки, и вложенные словари, и массивы. В ответе АПИ по ключу **result** вернется **массив** со всеми апдейтами от бота.

Даже если новое сообщение будет всего одно — из result мы получим *массив* с одним апдейтом (сообщением). Он будет под нулевым индексом конечно, а длина массива будет соотвественно 1.

Это важно, потому что массив даже с одним элементов можно обойти при помощи цикла for. Этим мы и займемся дальше в уроке.

```python       
result = get_bot_updates(5)

# получаем текст сообщения
first_update = result[0]

message = first_update['message']
text = message['text']
update_id = first_update['update_id']

# также можем это сделать в одну строку
text = result[0]['message']['text']
update_id = result[0]['update_id']

# выводим текст сообщения
print(update_id, text)
```        
        
Чтобы отметить апдейты прочитанными, нам нужно передавать еще один параметр **offset**. Чтобы offset сработал, он должен быть на единицу больше, чем **update_id** последнего полученного нами сообщения. Он как-будто говорит АПИ: *«Дай мне все новые сообщения, начиная с этого айди»*.

ID сообщения мы научились получать выше. Давайте теперь отметим сообщение прочитанным. Для этого нужно будет переписать функцию **get_bot_updates**, чтобы она могла получать offset:
   
```python      
def get_bot_updates(limit, offset):
    url = "https://api.telegram.org/<token>/getUpdates" 
    
    par = {'limit': limit, 'offset': offset} 
    result = requests.get(url, params=par)
	
    decoded = result.json()
    return decoded['result']
  
# Получим только пять апдейтов
result = get_bot_updates(5, 0)

first_update = result[0]
text = result[0]['message']['text']
update_id = result[0]['update_id']

new_offset = update_id + 1

# выводим текст сообщения и отмечаем прочитанным
print(update_id, text)
get_bot_updates(5, new_offset)
```           
  
Что мы только что сделали? Мы как и раньше получили 5 апдейтов с дефолтным *offset=0*. Только в этот раз после вывода сообщения мы получили новые апдейты и передали **new_offset**.
  
Но по одному получать сообщения и отмечать прочитанными просто неудобно. Здесь нам пригодится цикл **for**, про который мы узнали в первом уроке.

При помощи этого цикла мы сможем обойти весь массив сообщений и проделать одни и те же действия. И нам не нужно будет получить первый апдейт по индексу — мы сможем обработать сразу все.

```python
for item in result:
    text = item['message']['text']
    update_id = item['update_id']
    print(update_id, text)
```

**Важно на данный момент**:
- В *result* АПИ отдает **массив** сообщений, даже если сообщение одно. Внутри каждого элемента этого массива — словарь c информацией о сообщении.
- Чтобы получить сообщение по номеру — обращаемся по **индексу** к массиву *result*
- Чтобы получить информацию о самом сообщении, после индекса обращаемся по ключу
- Апдейт отмечается прочитанным, если передать **offset** на 1 больше, чем ID этого апдейта
- Чтобы не обращаться по индексу вручную, мы будем использовать цикл for

Теперь вы по аналогии должны написать функцию для отправки сообщений. Она будет использовать метод API [sendMessage](https://core.telegram.org/bots/api#sendmessage).

### Полезные ссылки
[Официальная документация бот-АПИ](https://core.telegram.org/bots/api)

[Русская неофициальная документация бот-АПИ](https://tlgrm.ru/docs/bots/api)

## Итог
Мы узнали о том, как работает интернет и запросы. Узнали про то, что весь код уже написан за нас и как использовать чужой код.

Научились делать запросы к сайтам из кода, а потом узнали, что это можно делать эффективнее через АПИ. Посмотрели на пример работы с бот-АПИ телеграма и приступаем к написанию своего бота. Если еще не читали задание, то оно на странице этапа.

• • •

# Почаще задавайте вопросы в чате — там обязательно помогут