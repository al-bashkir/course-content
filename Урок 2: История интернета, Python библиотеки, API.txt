#курс
# История интернета
Интернет создал Тим Бернерс-Ли, 6 августа 1991 года он запустил первый в мире сайт [info.cern.ch](http://info.cern.ch/) . Там он рассказал про новую технологию **WWW** (World Wide Web). Она базировалась на трёх принципах: протокол HTTP для передачи данных, системе адресации URI и языке разметки HTML.
## Структура интернета
### Про HTTP, URI и HTML
**HTTP** — это протокол передачи данных. Мы в любом порядке можем говорить слова и понимать друг друга. Но компьютеры не такие, им нужна точность. Разные программы постоянно обмениваются данными и это строгий процесс. В вебе для передачи данных используется протокол HTTP.

Основа HTTP — общение «сервер-клиент». **Сервер** — это система, которая по запросу от клиента отдаёт ему ответ. Взгляните на этот сайт. Для вас уроки выводит _фронтенд_ на Реакте (клиент), но сам текст уроков приходит с _бэкэнда_ на Python (сервера).

Обычно в вебе клиентом называют браузеры, но есть и другие способы сделать запросы: терминальные wget, curl; браузерные расширения вроде Postman, также можно сделать запрос прямо из кода.

## URI — система адресации
С сервером и протоколом мы разобрались, но теперь вопрос: а куда делать эти самые запросы? Да и как бэкэнд отделит один запрос от другого? Это сравнимо с адресами в городах. Для этого используется **URI** – универсальный идентификатор ресурса — это символьная строка, которая позволяет отличить бэкэнду один ресурс от другого.

```
  URI = [ схема + ":" ] иерархическая-часть [ "?" + запрос] [ "#" + фрагмент ]
```
        
**Примеры:**

`http://ru.wikipedia.org/wiki/URI?highlight=запрос`

`mailto:Vk.You@example.com`

`ftp://ftp.em.so.ca/rfc/presentation.pdf`

`tel:+1-800-111-1234`

Всё строится по одному формату: сначала говорим, что за протокол мы используем: http / ftp / mailto / tel. Затем идет иерархическая часть, по которой уже идет определение.   
  
У http есть ещё **query params**, в примере с Википедией это ?highlight=запрос. Они используются для уточнения для динамических ресурсов, например там могут передаваться ключевые слова для поиска на сайте.

## HTML — язык разметки

Мы разобрались, что мы попадаем на сервер через HTTP и отделяем страницы друг от друга при помощью URI (или, если быть точным, URL). С помощью урлов мы даже разделяем какие страницы нужно отдавать: на http://bluzir.me/python/course у нас одна страница, а на http://bluzir.me — другая.

Но что такое **страница**? Изначально весь Веб был построен на простейших страницах — это были простые документы, которые лежали в интернете. Как *.pdf* или *.docx* файлы, только для этого использовался свой открытый стандарт.

Что самое важное в документе? **Разметка**. Чтобы не пришлось всё писать одним сплошным текстом вам требуются абзацы, заголовки, цвета, ссылки. Представьте, как неудобно было бы читать этот урок без всего этого. К счастью, всё это есть в HTML. Мы подробно поговорим про html, когда будем делать наш первый сайт.

## GET и POST запросы
Еще одна важная вещь, на которой базируется HTTP-протокол — методы GET и POST. Запрос содержит эти методы и также важны для определения поведения бэкэнда, как и URI. 

### GET
Это самый стандартный метод. Вы сталкиваетесь с ним ежедневно, когда открываете любую страницу на любом сайте. Вы просто переходите по адресу в браузере, а уже он автоматически посылает за вас GET-запрос к серверу.

Таким образом GET используется для **получения** данных. В нашем случае данных веб-страницы. Query параметры из примера выше, также называются GET-параметрами. Они используются для уточнения запроса. Рассмотрим их на примере поиска на Гитхабе.

[https://github.com/search?l=Python&q=market&s=updated](https://github.com/search?l=Python&q=market&s=updated)

**l** — язык программирования 

**q** — поисковый запрос 

**s** — тип сортировки

На клиенте мы можем передать любые параметры. Реагировать на этот параметр или нет — решает уже сам сервер.

### POST
С этим методом вы тоже постоянно сталкиваетесь на сайтах. Особенно когда заполняете формы, отправляете сообщения, отправляете письма из почтового сервиса.

POST используется для **передачи** данных. Query-параметры при этом не используются. Данные отправляются рядом с запросом в виде похожем на словарь в Питоне. Это называется **телом** (body) запроса.

## Python-библиотеки
Про историю и веб мы поговорили. Время вернутся к Python и начать применять новые знания. 

Сразу раскрою небольшую тайну: на самом деле весь код уже написан за нас. Маловероятно, что кто-то до вас не столкнулся с такой же задачей или проблемой. Некоторые разработчики выкладывают решения этих задач в виде библиотек. Нам нужно только уметь их найти и применить.

**Библиотеки** — это сторонние программы для Python, написанные другими разработчиками и выложенные в открытый доступ. Библиотеки разделяются на встроенные и внешние.

### Встроенные библиотеки
Это все библиотеки, которые включены в стандартную сборку Python. Для python3 их около *150*. Для python2 еще больше — *430*. Большинство нам никогда не пригодится.

Нет смысла обсуждать их без практической необходимости. Рассмотрим пример лишь с одной библиотекой для работы с операционной системы — **os**.

Для импорта библиотеки мы используем ключевое слово **import**.

    import os 
    # вернет название директории, откуда запущен код
    print(os.getcwd()) 

Затем мы можем к ней обратиться по имени. В нашем примере **os** — библиотека, а **getcwd()** — функция внутри библиотеки, которую мы вызываем.

Таким образом, импортируется библиотека целиком. Иногда нам нужна только одна или несколько функций, тогда мы можем явно указать их названия в импорте:

    from platform import system 
    
    # Выведем информацию об операционной системе
    print(system())

В этом примере мы импортировали из библиотеки **platform** только функцию **system** и вызываем её.

Вы точно также можете импортировать функции, списки, словари и из своих соседних файлов.

`from settings import SECRET_KEY` — при условии, что рядом лежит файл **settings.py** и в нем есть переменная **SECRET_KEY**. Это удобно, когда нам нужно разделить большой файл на несколько небольших.

### Внешние библиотеки
Они отличаются от встроенных тем, что их нужно сперва установить и только потом можно импортировать в коде. Для установки нам понадобится встроенный менеджер пакетов (библиотек).

Он называется **pip** (Python Package Index) и идет в комплекте с Python. У него тоже нет графического интерфейса и работает при помощи команд.

Здесь ситуация аналогичная вызову python. Для Виндоус используем pip, для Мака pip3.

_`pip install <название-библиотеки>`_ — установит нам нужную библиотеку. В таком случае она установится глобально — для основного системного Python. Это считается не очень хорошей практикой. Когда вы напишите 5 или 10 приложений, таких библиотек может накопится десятки и они могут начать конфликтовать между собой.

Хорошей практикой считается иметь своё отдельное Python-окружение для каждого проекта и устанавливать библиотеки туда. В этом нам поможет утилита **pipenv**.
 
### Pipenv
На данный момент это лучший способ для работы с окружениями в Питоне. Это тоже библиотека и как раз она нужна нам глобально — установим её.

_`sudo pip install pipenv`_

Для команды **sudo** требуются права администратора. На Windows потребуется открыть терминал из под администратора, на Маке просто ввести пароль после ввода команды.

Теперь из директории нашего проекта мы можем создать окружение и установить в него библиотеки. Для этого просто вводим команду:

_`pipenv install requests`_

Pipenv автоматически развернет окружение и установит в него библиотеку **requests**. Она потребуется нам, чтобы делать http-запросы из кода. После установки она станет доступна для импорта в нашем коде.

Теперь мы должны активировать окружение командой _`pipenv shell`_. Важно следить, чтобы окружение было активировано, когда мы запускаем код. Это можно понять по строке в терминале. 

Теперь мы можем писать код. Давайте сделаем запрос к страничке курса:

```python   

  import requests
  
  # Выведет HTML страницы моего курса
  result = requests.get("https://bluzir.me/python/course")
  print(result.text)
```  
          
Так, погодите, что мы только что сделали? Почти ничего нового, что нам было бы неизвестно:

- Импортируем библиотеку **requests** целиком
- Обращаемся к встроенной в библиотеку функции **get**
- Он делает то же самое, что и браузер при переходе по ссылке — делает **GET**-запрос.
- Результат выполнения метода мы кладем в переменную **result**
- Принтим текст результата
- Видим html разметку страницы курса
 
На самом деле здесь есть неизвестный нам момент — обращение к объекту через точку при вызове функции **get**. Про это мы подробнее поговорим на следующей неделе, а пока функции из библиотек вызываются таким образом. Кстати, такие функции еще называются методами.

**Дополнительно**
- [Документация библиотеки requests](http://docs.python-requests.org/)
- [Руководство по работе с requests в Python](https://khashtamov.com/ru/python-requests/)

## Итог 
Сначала мы изучали базовую историю интернета и разобрались, как он работает.

Мы узнали, что библиотеки бывают внешние и встроенные. Скачали библиотеку *requests* и сделали с её помощью наши первые запросы.

• • •

# Почаще задавайте вопросы в чате — там обязательно помогут
