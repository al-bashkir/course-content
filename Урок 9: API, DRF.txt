## Теория

На первой неделе мы уже говорили про АПИ и историю интернета. Перечитайте этот урок. После трех недель обучения вы сможете взглянуть на него по новому. Тогда мы пользовали АПИ телеграма, теперь мы будем разрабатывать свое. 

Все шаблоны у нашего интернет-магазина статичны. Их обрабатывает и рендерит сервер, после чего страница отображается на сайте. Такая реализация подходит для небольших магазинов, блогов, систем управления. Однако, сложные интерфейсы требуют мощного фронтенда — современные сайты используют ReactJS, Angular, VueJS. Все эти технологии требуют, чтобы данные возвращались с сервера при помощи АПИ. 

Существуют разные виды АПИ: некоторые системы используют **SOAP API** на основе протокола XML. У него есть стандарт и требования, работать с ним не самое большое удовольствие. Большинство современных сайтов используют **JSON API** — такое как у Телеграма. 

Но API отличаются не только протоколом, но и архитектурой. Мы будем использовать архитектурный стиль — **REST**. REST расшифровывается как _Representation State Transfer_ — передача состояний представления. При таком подходе получается упрощенная архитектура и улучшается производительность.

Основная фишка в том, что сервер не должен хранить информацию о состоянии клиента. Вся эта информация должна браться из запроса. Вспомните как мы передавали *offset* для бота, сервер при этом ничего не запоминал.

Обычный API запрос
`https://example.org/api/?method=getPosts&count=10`
						
REST запрос на получение массива объектов постов
`https://example.org/api/posts`
 
REST запрос для получения конкретного товара по ID
`https://example.org/api/posts/1`
					
Приложения, которые используют REST называют **RESTFul**. 
Запросы к таким АПИ делаются при помощи методов GET, POST, PUT, DELETE и используют систему **CRUD**: Create-Read-Update-Delete.

### Примеры

Так может выглядеть API для нашего магазина:

**GET /products/** — получить список всех товаров

**GET /products/3/** — получить товар c ID = 3

**PUT /products/** — добавить книгу (данные о товаре в теле запроса)

**POST /products/3** – изменить книгу (данные о товаре в теле запроса)

**DELETE /products/3** – удалить товар

Подробнее изучить РЕСТ вы можете при помощи [REST-туториала](http://www.restapitutorial.ru/).

## Django REST Framework

Как вы помните Джанго сам по себе является фреймворком. Их не бывает много, поэтому для работы с REST поверх Джанго сделали еще один фреймворк — **DRF** (Django REST Framework).

Он такой же мощный, как и сам Джанго и по нему одному можно делать отдельный курс. Мы разберемся с его основами. Для начала установим его в нашу виртуальную среду:

_`pip install djangorestframework`_

Теперь остается только добавить _`'rest_framework'`_ в _INSTALLED_APPS_ наших настроек и DRF готов к работе.

Теперь мы можем почти сразу использовать его в нашем приложении. Процесс превращения объектов модели в текстовый формат (JSON) называется **сериализацией**. Эту функциональность DRF мы и будем использовать. Для этого над понадобится создать файл _serializers.py_ в директории нашего приложения.

DRF использует все лучшее, что есть в Джанго и умеет строить АПИ из моделей полуавтоматически:

_shop/serializers.py_
```python
from rest_framework import serializers
from .models import Product

class ProductSerializer(serializers.ModelSerializer):

class Meta:
model = Product
  fields = ('id', 'title', 'description')
```					
					
_shop/views.py_
```python
from rest_framework import generics

class ProductListAPI(generics.ListCreateAPIView):
queryset = Product.objects.all()
serializer_class = ProductSerializer
```					

_urls.py_
```python
path('api/products/', views.ProductListAPI.as_view(), name='api_products_list'),
```						

Теперь по адресу **127.0.0.1:8000/api/products** мы увидим страницу нашего API. По дефолту она загрузится с веб-интерфейсом. Чтобы увидеть чистый API нужно дополнительно в строку передать параметр с форматом:

**http://127.0.0.1:8000/api/users/?format=json**

Если мы хотим, чтобы ответ от API по дефолту отдавало текстовый формат, то нужно изменить **рендерер**. Добавим в наш Вью строку:

`renderer_classes = (JSONRenderer, BrowsableAPIRenderer)`

Только не забудьте импортировать их из `rest_framework.renderers`

Теперь по дефолту мы будем получать текстовый вариант, а веб-версия станет доступна по адресу:

**http://127.0.0.1:8000/api/users/?format=api**

А что если мы хотим сделать API доступным только для администраторов? Это не сложно, импортируем в файле с Вью `from rest_framework import permissions`. Теперь в нашем Вью мы можем прописать аргумент с ограничениями: `permission_classes = (permissions.IsAdminUser, )`. Теперь для доступа к АПИ нужно будет передавать логин и пароль в Хэдере при запросе:

```python
url = "http://127.0.0.1:8000/api/users/"
headers = {'Authorization': 'login:password'}
r = request.get(url, headers=headers)
```

[Официальный сайт DRF](http://www.django-rest-framework.org/)

[DRF туториал](http://www.django-rest-framework.org/tutorial/1-serialization/)

## Задания:

— Пройдите Рест Туториал. 
— Сделайте АПИ с которым сможет работать ваш Телеграм бот. Подумайте, какую информацию можно отдавать через открытое АПИ, а к какой лучше ограничить доступ только для админов.