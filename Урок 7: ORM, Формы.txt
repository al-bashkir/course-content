## Вступление
В прошлом уроке мы уже начали говорить про модели и научились получать из них данные. Но на самом деле просто записать название модели в **ListView** не всегда достаточно. Иногда нужно отфильтровать модель, иногда передать несколько разных моделей в один Вью.

Для всего это используется **ORM** (Object-Relational Mapping) — объектно-реляционное отображение. С объектами понятно, это объекты наших моделей. Но что за реляционное отображение?

Мы уже начали говорить про базу данных и таблицы. Поняли, что таблицы могут связываться с друг другом при помощи внешнего ключа. Так вот, базы данных, где таблицы могут связываться и называются реляционными.

В ORM входит не только представление таблицы БД в виде класса, которое мы разобрали на прошлой неделе (наш *models.py*). А также интерфейс для получения данных из этой модели в любое месте сайта.

Звучит немного запутанно, но это все еще обычный код на Питон. А лучше их понять нам поможет лучший друг при разработке на Джанго.

## Django Shell

Нужно протестировать какой-то запрос к модели? Джанго Шелл поможет. Вызывается он уже знакомым нам способом через **manage.py**:

_`python manage.py shell`_

У нас открылась обычная Питон консоль, которая открывается, когда вы вводите *python* в терминале. За исключением, что теперь из нее можно работать с нашим Джанго-проектом.

Теперь мы можем делать там все тоже самое, что делаем в питон-файлах: объявлять, вызывать, импортировать. Сначала импортируем нашу модель Продуктов:

`from shop_app.models import Product`

Мы получили в консоли доступ к классу модели Продукта. Теперь мы можем получать объекты и фильтровать их.
```python       
# вернет список всех продуктов
Product.objects.all()
# вернет продукт с определенным ID
# get может вернуть только один результат, можно использовать только для фильтрации по уникальным полям
Product.objects.get(id=2)
# вернет отфильтрованный список продуктов, можно использовать для любых полей
# для работы этого примера нужно добавить поле с ценой для товара
Product.objects.filter(price__gt=5000)
# отфильтруем модель через ForeignKey
# __ позволяет обращаться к полям связанной модели
Product.objects.filter(category__id=1) 
```           
          
Таким вот образом мы смогли вывести дополнительные товары в методе `get_context_data`.

## Продвинутая работа с урлами

Вспомните, как выглядит наш URL из файла **urls.py**:
```python
path('products/<int:pk>', views.ProductDetail.as_view(), name='product_detail'),
```
Первым аргументом мы назначаем саму ссылку. Вторым передаем Вью, а вот про третий аргумент я забыл рассказать. Это именованный аргумент, нужен для того, чтобы обращаться к этому пути по названию.

В нашем коде мы можем получить его так:
```python          
# встроенная функция для генерирования ссылок по их названию
from django.urls import reverse

# Получаем откуда-то айди, и создаем ссылку целиком
reverse('product_detail', args=[str(id)]
```                    

В коде создавать ссылку таким способом приходится редко. Куда более частый пример — создать ссылку по имени в шаблоне. В Темплейте ссылку на наш продукт мы можем сгенерировать таким образом:

`{% url 'product_detail' product.id %}`, где **product_detail** — именованное название нашей ссылки из *urls.py*, а product.id — ID которое мы передаем туда, как аргумент.

Мы можем использовать такой способ для ссылок на товары и категории.

[Работа с именнованными ссылками в Темплейте](https://docs.djangoproject.com/en/2.0/topics/http/urls/#reverse-resolution-of-urls)

## Формы

На сайтах вы постоянно взаимодействуете с формами для передачи информации сайту. Самые обычные формы пишутся на HTML используя тег **<form> </form>**.

Основная функция этих форм — передавать данные на сервер. Поэтому у любой формы должно быть два обязательных аттрибута: адрес куда будет делать запрос – **action**, а также тип самого запроса (GET или POST) — **method**.

POST в формах используется когда нужно передать фоном какие-то данные на сервер и получить ответ, например форму оплаты. GET используется, когда нужно сформировать get-запрос — например в поисковых формах. Вспомните как мы рассматривали поисковый запрос на Гитхабе на первой неделе.

Использовать HTML-формы не очень удобно. Их нужно писать вручную на HTML, там нет полноценной валидации и форму нельзя сгенерировать сразу из нашей модели. О безопасности таких форм тоже нужно думать самому. Никому ведь не хочется, чтобы твой новый сайт по продаже мороженного тут же взломали? Тут к нам на помощь приходит Джанго со своими **Django Forms**.

### Джанго-формы
Это абстракция над html-формами. Их синтаксис частично напоминает синтаксис моделей. При помощи Джанго-форм мы можем принимать данные, валидировать их и сразу сохранять в объект модели. На самом деле Джанго-формы нужно использовать для валидации любых поступающих данных. Вы уже сталкивались с Джанго-формой, когда заходили в админку.

Самую простую форму можно создать автоматически из любой модели. В этом нам помогут Классовые-вью, которые мы начали использовать на прошлой неделе, а именно **CreateView**. Мы можем использовать его так:

*shop_app/views.py*
```python
class ProductCreate(generic.CreateView): 
	model = Product 
	# название нашего шаблона с формой
	template_name = 'product_new.html' 
	# какие поля будут в форме 
	fields = '__all__'
```  
          
*shop_project/urls.py*
```python
# наш View для конкретного продукта из прошлого урока
path('products/<int:pk>', views.ProductDetail.as_view(), name='product_detail'),
# добавляем новую строчку в urlpatterns
path('products/new/', views.ProductCreate.as_view(), name='product_create'), 
```            
          
*shop_app/templates/product_new.html*
```
  <h1>Создаем новый пост</h1>
  {# action — ссылка куда отправляется запрос, method - метод запроса #}
  <form action="" method="post" enctype="multipart/form-data">
    {% csrf_token %} 
    {{ form.as_p }} 
    <input type="submit" value="Подтвердить" /> 
  </form>
```     
    
Что мы только что сделали? Создали форму через **CreateView**, указали там название нашей модели и шаблона. Затем написали по какой ссылке она будет доступна через **urls.py**.

После этого нужно добавить форму в сам шаблон — нам понадобится базовый html, остальное все сделает сам Джанго. Джанго форма передается в контекст по ключу _`{{form}}`_ , так мы её и вызываем в шаблоне. **as_p** — просто обернет форму в тег параграфа для вертикального отображения. Про **csrf_token** мы поговорим дальше в уроке.

Теперь когда мы все это добавили, то можем наконец увидеть нашу форму по ссылке `127.0.0.1:8000/products/new/`. Однако после заполнения формы мы получим ошибку *No URL to redirect to*. Она возникла из-за того, что мы не указали URL для редиректа в нашем Вью — по какой ссылке нас отправит форма после создания продукта.

Но есть более универсальный способ, чем просто указать ссылку для редиректа. Добавим нашей модели продукта метод **get_absolute_url** — в этом методе мы реализуем получение ссылки на конкретный товар через именованный УРЛ.

*shop_app/models.py*
```
  from django.urls import reverse
  
  class Product(models.Model): 
    title = models.CharField(max_length=200)
    ...
    
    def get_absolute_url(self): 
      return reverse('product_detail', args=[str(self.id)])
```              
            
Внутри метода мы используем уже знакомый нам метод создания ссылки по имени и аргументу. Теперь после заполнения формы нас будет перенаправлять на страницу товара.

По аналогии с **CreateView** также существуют **UpdateView** и **DeleteView** для редактирования и удаления объектов моделей соотвественно.

[Документация Джанго-форм](https://docs.djangoproject.com/en/2.0/topics/forms/)

[Документация CreateView, UpdateView, DeleteView](https://docs.djangoproject.com/en/2.0/ref/class-based-views/generic-editing/#createview)

## CSRF-защита
Я уже говорил, что Джанго берет не себя не только валидацию форм, но и безопасность. Благодаря встроенной обработке полей мы избавляемся от опасности XSS-уязвимостей. Еще одна защита, встроенная в Джанго называется **CSRF-токен**.

Представьте себе форму, которая отвечает за перевод денег между счетами банка. После заполнения она совершает запрос:

`http://bank.example.com/withdraw?account=our_account&amount=1000000&for=friend_account`
          
После запроса деньги переводятся с нашего счета на счет друга. Видите в чем может быть опасность? Владелец другого сайта может вставить такой код запроса в форму на своей сайте или вообще в код загрузки страницы?. Тогда бы через запрос к банку наши деньги могли бы перевестись злоумышленнику.

Такой тип атаки называется Сross Site Request Forgery — **CSRF**.

Поэтому в ПОСТ-запросах, которые изменяют данные, требуется передавать **csrf_token**. На сервере он будет сверяться и так сайт сможет понять, что запрос делаете именно вы.

[Межсайтовая подделка запроса](https://www.wikiwand.com/ru/%D0%9C%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0)

## Продолжаем работать с формами

До этого мы создали Формы для создания, редактирования и удаления наших товаров. Это конечно здорово, но не очень полезно для нас, поскольку дублирует возможности админки. Интереснее было бы сделать форму для пользователей.

В любом интернет-магазине должна быть возможность сделать заказ, так? Давайте реализуем. Для начала нам нужна базовая модель заказа **Order**:

*shop_app/models.py*
```python
class Order(models.Model): 
  product = models.ForeignKey(Product, on_delete='CASCADE') 
  customer_name = models.CharField(max_length=200)
  customer_phone = models.CharField(max_length=200)
```
          
Для создания заказов мы будем использовать уже нам известный **CreateView**:

*shop_app/views.py*
```
class OrderFormView(generic.CreateView): 
  model = Order 
  template_name = 'order_form.html' 
  success_url = '/' 
  fields = '__all__'
```
         
Теперь зададим URL по которому мы будем отображать форму заказа для товара:

*shop_app/urls.py*
```
urlpatterns = [
      path('products/<int:pk>/order', views.OrderFormView.as_view(), name='product_order'),
]
```
      
Через **<int:pk>** мы будем получать ID товара, как и в **DetailView**.

Остается сделать шаблон:

*templates/order_form.html*
```python
<h1>Заказ товара</h1>
<form method="POST"> 
  {% csrf_token %} 
  {{ form.as_p }} 
  <button type="submit" class="save btn btn-default">Заказать</button>
</form>
```
          
На страницу заказа нужно как-то попадать. Добавим кнопку заказа на страницу товара, используя знакомый нам именованный УРЛ:

```
<button><a href="{% url 'product_order' product.id %}">Заказать</a></button>
```         

Перейдя по кнопке мы попадаем на станицу товара. Так, а почему мы тут видим поле выбора товара? Мы же уже выбрали товар? В отличие от *DetailView* передача ID здесь не происходит автоматически и её нужно будет запрограммировать вручную.

Для этого будем использовать встроенный в *CreateView* метод **form_valid**, а также покажем в самой форме только нужные поля:

*shop_app/views.py*
```python
class OrderFormView(generic.CreateView): 
  model = Order 
  template_name = 'order_form.html' 
  success_url = '/' 
  # выведем только поля, которые нужно заполнить самому человеку
  fields = ['customer_name', 'customer_phone']
  
  def form_valid(self, form):
      # получаем ID из ссылки и передаем в ORM для фильтрации
      product = Product.objects.get(id=self.kwargs['pk']) 
      # передаем в поле товара нашей формы отфильтрованный товар
      form.instance.product = product 
      # super — перезагружает форму, нужен для работы
      return super().form_valid(form)
```         

Теперь ID товара будет автоматически получаться из ссылки и сохраняться в форму. После чего будет создаваться новый объект нашей модели. Новый заказ вы можете увидеть в админке.

Кстати, на страницу формы вы также можете передать информацию о самом товаре через метод **get_context_data** также фильтруя его по параметру из URL. Также можете добавить страницу успешного оформления заказа и направить на нее редирект через **success_url**.

## Итог

В этом уроке мы научились делать формы. Узнали, что они как и все в Джанго делаются очень просто. А потом сделали собственную форму для создания товара.